### CH2 变量和基本类型
## 
> 总结：  
> 1. extern 用于声明变量，而非定义变量；C++ 支持将变量的 声明和定义 分开！  
> 2. const 用于修饰常量，它是 编译时常量！也就是说在编译时该变量的值就会被常数替换掉！必须初始化，且值不允许再修改！
## 
 
#### 2.1 基本内置类型 与 类型转换
1. 数据类型：程序的基础，定义了 数据的意义 及其上可执行的操作！

2. C++ 的基本内置类型
	* **算术类型** (arithmetric type)
		* 整型 (integral type)  
		(eg: char, bool, short, int, long, long long)
			- 带符号类型 (signed): 最高位用作符号位 [-128, 127]
			- 无符号类型 (unsigned): 所有比特位都用来存储值 [0-255]
		* 浮点型  
		(eg: float, double, long double)
		 
	* **空类型** (void type)
	
	> 建议：如何选择数据类型？  
	> 1. 当明确知道数值不可能为负数时，选用 unsigned 类型；  
	> 2. 使用 int 执行整数运算，如果数值超出了int的表示范围，建议直接选择 long long;  
	> 3. 在算术表达式中，不要使用 char 或 bool 类型；  
	> 4. 执行浮点数运算 首选 double, 这是因为它本身计算代价与float相差无几，甚至对于某些机器，双精度甚至比单精度更快。
	
3. 类型转换 [source_code](./CH2_Variables_BasicTypes/type_conversion.h)
	* ❗️注意 `unsigned` 与 `signed` 之间的相互转化(关于符号位的不同理解)；
	* ❗️注意 `任何一种数据类型在计算机内部所占的位数` 对其本身所能表示的数据的范围的影响。
	* ❌ 切勿 `混用 signed与unsigned 类型`，因为带符号数会自动转换成无符号数从而产生异常结果。
	
	> 联系：java 里面 `int`与`Integer` 的主要不同就在于 `Integer`是无符号的整型 ( Integer = unsigned int )。

4. 字面值常量 (literal)
	* 整型和浮点型：十进制 20，八进制 024，十六进制，3.1415，3.14E0
	* 字符和字符串字面值：‘a’ | "Hello World!"
	* 转义序列：\n，\t，\0，\12(换行符)，\40(空格符)，\x4d(字符M)，\123，etc.
	* 布尔型字面值：true, false
	* 指针型字面值：nullptr

## 
#### 2.2 变量 及其 初始化

1. 何为变量？何为对象？
	* *变量* 是一块 具名的、可供程序操作的 存储空间。
	* *对象* 也是一块 能存储数据并具有某种类型 的内存空间。

2. 初始化 和 赋值操作 的区别：
	* 初始化 不是赋值，初始化指的是：在变量创建时为其赋予一个初始值，而赋值强调的则是：把一个对象的当前值擦除，并以一个新值进行替代！

3. 关于 **变量初始化**
	* 如果内置类型的变量定义时未被显式的初始化，那么它的初值将由其定义的位置决定：
		- 定义在任何函数体之外，初始化为 0；
		- 定义在函数体内部，将不被初始化，初值为 undefined。  
		此时如果试图拷贝或访问，将引发错误(error / bug)！
	
	> 定义于函数体内的内置类型的对象，如果没有初始化，则其值为未定义！  
	> 用户自定义的 类的对象 如果没有显式地初始化，则其值由类本身来确定！
	
	Tips: <font color="blue">建议在定义每一个内置类型的变量时，都对其进行显式的初始化，虽然并非必须这么做，但为了确保程序安全，这么做不失为一种简单且可靠的方法！</font>
	
4. C++ 为什么要将 声明 和 定义 区分开来？
	* 是为了要支持分离式编译，从而支持将程序拆分成多个逻辑部分来编写！
	* **声明 (declaration)**: 负责规定变量(或对象)的类型和名字；   
	  **定义 (definition)**: 除了声明变量之外，还需要为它申请存储空间，甚至是赋予一个初值！
	* 举例：C++ 声明变量：`extern int i;` 定义变量：`int i;`
	> 变量 只能被定义一次，但却可以被多次声明！

5. C++ 是一种 静态类型 语言，这就要求我们在使用某个变量之前必须先声明其类型！
	* 静态类型语言的特点：在编译阶段就进行类型检查，编译器负责检查数据类型是否支持要执行的运算，如果试图执行其类型所不支持的运算，编译器就会报错！

## 
#### 2.3 复合类型 之 指针与引用

1. 定义：复合类型(compound type) 是指 基于其他类型定义 的类型。比如：指针 与 引用 等。

2. 引用 (reference): 为对象起了另外一个名字，`引用即别名` 引用不是对象
	* 举例：
	  
	```
	int a = 1024; 
	int &b = a; // ✅ b 是 a 的别名，引用变量 b 指向 a
	int &c; // ❌ 报错：引用必须被初始化（一定要指出是谁的别名）
	```
	
	> 引用 必须以符号 `&` 开头，而且引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起！
	
3. 指针
	* 指针本身就是一个对象，可以对其进行赋值和拷贝。
	* 切记：不要访问空指针和无效指针！
	* 解引用操作 `*` 仅仅适用于那些确实指向了某个对象的有效指针！
	
	> 指针 定义必须以符号 `*` 开头，指针对象所存放的是“某个对象的地址”
	
4. `void*` 指针
	* 这是一种特殊的指针类型，可用与存放任意类型对象的地址！
	* 它基本没啥用，因为我们并不知道它所指向的对象到底是什么类型，所以无法确定其操作！

5. 总结：
	* `&, *` 引用和指针 只被称作是`类型修饰符`，它其实只不过是变量声明符的一部分罢了，而不是`数据类型`本身。  
	所以 `int* p1, p2; //定义的是：p1: int型的指针，p2则只是int类型而已！`
	正确写法：`int *p1, *p2;` 或者是 `int* p1; int* p2;`
	* 类型修饰符可以级联，表示 指针的指针 或者是 引用的引用。
		- **指针的指针**：`int **p;`
		- **指针的引用**：`int *p; int* &r = p;`
		- 不可以出现引用的指针：因为引用本身不是对象！
		- 不可以出现引用的引用：因为引用本身不是对象！
		
	> 要理解 r 的类型到底是什么，一个最简单的方法就是：从右向左阅读 r 的定义！  
	> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读 有助于弄清楚它的真实含义！

## 
#### 2.4 const 限定符 定义及其作用域

1. const 限定符出现的初衷
	* 希望定义一个变量，又不希望该变量的值被改变！(用 `const` 来修饰，声明其为常量)
	* `const` 对象一旦创建后，其值将不被允许再改变，所以它必须初始化！
	* 其实这真的就是一个限定符，限定了原数据类型上的一些写操作，另其`只能读不能写`！
	
2. const 对象的作用域问题
	* 默认情况下，const 对象仅在当前定义的文件内有效，其他文件内无效！
	* 如果想在多个文件之间共享 const 对象，则必须在该const变量的定义和声明之前都添加 `extern` 关键字！
	
	```
	// file1.cpp, 用 extern修饰 变量定义 说明会被其他文件共享
	extern const int bufSize = 512;
	// file2.cpp
	extern const int bufSize;
	```
	
3. 对 const常量 的引用
	* 不要试图让一个非常量引用 指向 一个常量对象！
	
	```
	const int bufSize = 1024;
	const int &r1 = bufSize; // ✅
	int &r2 = bufSize; // ❌ 不能让非常量引用指向一个常量对象
	r1 = 1025; // ❌ 不能通过常量引用来试图修改 const常量的值
	```
	* const常量引用 的初始化，可以用任意类型的表达式！

	```
	int i = 42;
	double d = 3.14;
	const int &r1 = i; // ✅ 这里 const 其实是想表达 约束 r1上的操作
	const int &r2 = 42; // ✅ 用 const 修饰则不允许对其进行修改
	const int &r3 = r1*2; // ✅ 只允许通过 r1, r2, r3, r4 来读取数值
	const int &r4 = d; // ✅ 所以这里不在意右边是什么类型的对象
	int &r5 = r1; // ❌ 这里 r5 是非常量引用，不允许类型不一致
	```
	
4. 对 const常量 的指针[**底层const**] vs. 常量指针(int *const ptr = &a;)[**顶层const**]
	* Rule-1: 不要试图用 指向const常量的指针 来修改该常量的值！
	* Rule-2: 不要试图让 一个非常量的指针 指向一个常量对象！
	
	```
	const double pi = 3.14;
	const double *ptr1 = &pi; // ✅ 指向常量的 指针
	double *ptr2 = &pi; // ❌ Rule-2
	*ptr1 = 6.28; // ❌ Rule-1
	
	double db = 1.23;
	double *const ptr = &db; // ✅ 指向普通变量的 常量指针
	```
	* const常量指针 的初始化，也可以用任意类型的表达式！(参考 const常量 引用)

	> 注意区分：指向常量的指针(**int *ptr**) vs. 常量指针 (**int *const ptr**)  
	> 因为指针本身也是一个对象，所以这个对象本身也可定义为const，从而形成 常量指针 的概念!

5. C++11 新增：常量表达式 (const expression)类型 [**`constexpr`**类型]
	* 定义：是指 值不会改变(const) 且 在编译阶段就能得到计算结果 的表达式！
	
	```
	// C++ 11 新特性, 允许定义 constexpr类型 
	// 以便 编译器 来验证变量是否是一个常量表达式
	constexpr int test_const_expr = 2048; 
	```
	
	> 注意：1. 声明为 `constexpr` 类型的变量一定要是一个常量 并且 必须用一个常量表达式进行初始化！  
	> 2. 一般来说，如果你认定变量是一个常量表达式，那么就把它直接将其声明为 `constexpr`类型！让编译器帮你检查一下！
	
## 
#### 2.5 对类型的处理

1. 别名处理：定义 `类型别名` 的两种方法：
	* 法一：使用 **typedef** 关键字  
	`typedef double base, *dbptr; // base 等价于 double, dbptr 等价于 double*`
	* 法二：使用 **using** 关键字 [C++11 新特性]
	`using SI = Sales_item; // SI 等价于 Sales_item`
	
2. `auto` 类型说明符 [C++11 新特性]
	* `auto` 类型说明符目的是：用它来让编译器替我们分析一个表达式到底是什么类型，而不需我们自己人为分析和指定类型。
	* 注意：用 `auto`定义的变量必须赋予初始值！
	 
3. `decltype` 类型指示符 [C++11 新特性]

## 
#### 2.6 自定义数据结构

1. 如前所述，我们可以这样理解“数据结构”：	
	* **数据结构** 就是把一组相关的数据元素组织起来，然后使用它们的策略和方法。 
	* **数据结构** 是 **数据** 及 其上所允许的**操作** 的一种逻辑组合。
	
2. 头文件的编写 与 程序的预处理
	* 为了防止 头文件 被重复包含，C++程序会用到一项预处理的功能：头文件保护符！  
	
	```
	#ifndef HEADER_H
	#define HEADER_H
	...
	#endif
	```
	
## 
END [Back](../part1-foundation.md)
## 

