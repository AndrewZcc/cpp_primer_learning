### CH7 类
## 
> 类 允许用户定义属于自己的数据类型！  
> 类 的基本思想是：**数据抽象**(能定义数据成员和函数成员) 和 **封装**(能保护类成员不被随意访问)。
## 

#### 7.1 定义 抽象数据类型

> `抽象数据类型(ADT)`定义：是指那些封装了具体实现细节的数据结构！  
> 数据抽象的作用是：能帮助我们把 对象的具体实现 与 对象所能执行的操作 分离开来。  

1. 类 与 结构体 的重要区别
	- 类 对自己的数据成员实现了封装，外部无法访问类对象的数据成员；而 结构体 则直接把数据成员展现给用户，让用户自己去访问和使用这些成员。
	
2. **类设计(接口的设计)也需要站在用户的角度来考虑**，也就是说：当我们设计类的接口时，应该考虑如何才能使得类变得易于使用；而当我们使用类时，就不再应该考虑具体的实现细节。
	- 类 的成员函数 声明必须在类的内部，定义则既可在内的内部，也可在类的外部。

3. `构造函数` 的作用：初始化对象的数据成员！无论何时只要类的对象被创建，就会执行构造函数！
	- 构造函数 控制类对象的初始化过程！
	- C++11 新标准中，引入`default`关键字来要求编译器生成默认构造函数！
	
	```
	struct Sales_data {
		Sales_data() = default;			// ✅ 编译器会生成 默认构造函数；
		Sales_data(const string& s) {}	// 又一个用户自定义的构造函数。
	}
	```
	
4. ❗️关于C++中的`动态内存`，使用标准库中的 `vector`和`string`对象帮助我们来管理存储空间，能有效地降低很多分配和释放内存所带来的复杂性。

#### 7.2 访问控制 与 封装
1. 为什么C++要提出类的概念？
	- 类的设计者可以通过`访问说明符`(**public, private**)对类进行封装，这一点 结构体 就做不到！
	
	- <font color="red">使用 class 和 struct 定义类唯一的区别就是 *默认的访问权限*</font>！(class 默认访问权限是 private，而 struct 默认访问权限则是 public)。

2. **友元** 的作用 [source_code](./class_try.h)
	- 类可以允许 其他类或者函数访问 它的非公有成员(private/protected)，方法就是：将其(类或函数)申明成为它的友元 [加上一条以 friend 关键字开始的函数声明即可]。
	
	```
	// 声明 友元函数
	class Sales_data {
		friend int multiply(Sales_data s);
		...
	};
	// 声明 友元类
	class Screen {
		friend class Window;
		...
	};
	class Window {
		...
	};
	```
	
	- **友元函数 和 友元类的成员函数 均可以访问此类的 包括非公有成员在内的所有成员**！（这就是友元最大的作用）
	
	- 注意：友元声明的作用仅仅是影响访问权限，而其本身并不能代替普通意义上的函数或类声明。也就是说：如果你仅仅进行了友元声明而没有真正的声明一个函数，那么在这个函数被真正声明前，它仍不可被调用。
	
	- ❗️另外注意：友元关系不具有传递性，每个类必须负责控制自己的友元类和友元函数。
	
#### 7.3 类的 其他特性
1. 类类型：要求每个类定义唯一的类型。
	- 这里请注意：即使两个类的成员列表完全一致，它们也属于不同的类型！
	
2. 对一个类来说，在我们创建它的对象之前**该类必须被定义过**，而不能仅仅只是被声明！

#### 7.4 类的 作用域
- 一个类 就是 一个作用域：这个事实很好的解释了为什么我们在类的外部定义成员函数时必须同时提供类名作用域 和 函数名！在**类的外部，成员的名字已经被隐藏起来**了！

#### 7.5 构造函数 再探
1. ❗️思考 **`构造函数初始值列表`** 与 `构造函数的赋值初始化` 之间的区别：
	
	```
	class ConstRef {
		private:
			int i;
			const int coni;
			int &refi;
		public:
			ConstRef(int a);
	}
	// 赋值初始化（本质上是：先执行默认初始化，之后再赋值）
	ConstRef::ConstRef(int a) {		// ❌
		i = a;		// ✅
		coni = a;	// ❌
		refi = i;	// ❌
	}
	// 构造函数初始值列表 (本质上是：直接初始化数据成员)
	ConstRef::ConstRef(int a) : i(a), coni(a), refi(i) { }	// ✅	
	```
	- 注意：这里的成员是 const 和 引用(&) 类型，它们必须通过 `构造函数初始值列表` 的方式提供初值，而无法通过 `赋值初始化` 的方式进行初始化。
	- 类内部成员的 *初始化顺序是：它们在类定义中所出现的顺序*，第一个定义的成员首先被初始化，然后才是第二个，以此类推。
	 
2. 关于默认构造函数，请注意：在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数！

3. C++ `explicit`关键字
	- 按 C++ 默认规定，只传一个参数的构造函数默认也定义了一个 隐式类类型的转换函数！通过将构造函数声明为`explicit`，我们就可以抑制这种隐式转换，也就是说：<font color="red">explicit构造函数必须被显式调用</font>！
	
	- 发生隐式的构造函数调用(隐式的类型转换)，经常会给程序带来逻辑错误，而且这种错误一旦发生很难觉察，所以原则上：应该在所有的构造函数前面都加上 explicit 关键字，但 C++多个实参的构造函数本身就不能用于执行隐式转换，所以它们就无需声明为 explicit。
	
	> explicit 关键字只能出现在类内部的声明语句中
	
4. 什么是 C++中的 **聚合类** (定义：只含有公有成员的类，并具有其他几个特征)
	- 聚合类：用户 可直接访问其成员的 具有特殊初始化语法形式 的类。
	- 其他特征：所有成员都是 public，没有构造函数，没有类内初始值，没有基类，没有虚函数！

#### 7.6 类的 静态成员 (`static`成员)

1. 静态成员：是与类本身直接相关，而不是与类的各个对象保持关联的类数据成员。
	- 类 的静态成员：**独立于任何对象之外**，对象不包含静态数据成员有关的数据！类的静态成员被所有对象所**共享**！
	
	> static 关键字也只能出现在类内部的声明语句中

2. 静态成员 与 普通成员 的区别
	- 静态成员 与类本身直接相关，独立于类的各个对象，存在于任何对象之外；
	- 我们可以用静态成员作为 默认实参(右值)，而普通成员不行(左值)。

## 
END [Back](../part1-foundation.md)
## 