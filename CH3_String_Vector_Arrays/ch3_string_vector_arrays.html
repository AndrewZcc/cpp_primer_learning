<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>CH3 字符串、向量和数组</title>

</head>
<body>
<h3>CH3 字符串、向量和数组</h3>

<h2></h2>

<blockquote><p>本章介绍两种最重要的标准库类型：string 和 vector。string 是一个可变长的字符序列，vector 则是一组同类型对象的容器！<br/>
另外再介绍一种更复杂的内置类型：数组。</p>

<h2></h2></blockquote>

<h4>3.1 命名空间的 using 声明</h4>

<ol>
<li><code>using namespace std;</code> 注意结尾处的分号！</li>
<li><code>using std::cin; using std::cout;</code></li>
<li>❗️头文件不应包含 using 声明，因为它会被拷贝到所有引用它的文件中去，容易导致命名空间冲突！</li>
</ol>


<h2></h2>

<h4>3.2 标准库类型 <code>string</code></h4>

<ol>
<li><p>使用【要包含 命名空间std 和 头文件string】</p>

<pre><code> #include &lt;string&gt;
 using namespace std;
</code></pre></li>
<li><p>string类型的 定义和初始化<br/>
 <img src="stringInitialize.jpg" alt="" /></p></li>
<li><p>string对象上的 操作<br/>
 <img src="stringOperation.jpg" alt="" /></p>

<ul>
<li>注意：s.size() 函数的返回值是：<code>string::size_type</code><br/>
这是一个 无符号类型的值(<strong>unsigned</strong>)，并且能足够存下任何string对象的大小！</li>
<li>在 C++ 11 中，我们可以使用 <code>auto | decltype</code> 来声明那些我们并不确定知道的变量类型！</li>
<li><font color="red">切记：千万不要使用 <code>s.size() &lt; n</code> 这类混用了 unsigned数 与 signed数 的表达式，因为你会得到意想不到的错误(Bugs)！</font></li>
</ul>


<pre><code> int n = -10;
 str.size() &lt; n; // ❌ 会得到错误的运行结果(true)，这是因为在这里你混用了 unsigned数 和 signed数。
</code></pre>

<ul>
<li>string对象的加法<br/>
注意：<font color = "red">当字符串和字面值混用在一条语句中使用时, 切记必须确保每个 加法运算符(+) 的两侧的运算对象 至少有一个是 string!</font></li>
</ul>


<pre><code> string s1 = a2 + "def";               // ✅ OK
 //string s2 = "abc" + "def";          // ❌ 错误
 string s3 = s1 + ", " + "world";      // ✅ OK
 //string s4 = "abc" + ", " + s3;      // ❌ 错误
 记住：字面值是一种单独的字面值类型，而不属于任何其他类型，所以这里的 “abc” 并不是 string类型，而仅仅只是 字面值类型 而已！
</code></pre></li>
<li><p>对字符的处理<br/>
 <img src="charProcess.jpg" alt="" /></p>

<ul>
<li>使用 <code>for (auto &amp;c : str)</code> 语句实现逐字访问</li>
<li>使用引用</li>
<li>使用指针(数组下标)</li>
</ul>


<p> 注意：<font color="red">使用数组下标访问时，请一定要注意：必须事先检查 确保下标在合理范围之内。</font>[下标必须 大于等于0  且 小于 size()]</p></li>
</ol>


<h2></h2>

<h4>3.3 标准库类型 <code>vector</code></h4>

<ol>
<li><p><code>vector</code> 是一个类模板，它是对象的集合。</p>

<ul>
<li>注意：vector 本身是模板，而并非是类型，由vector模板实例化才能得到具体的类型，例如：vector&lt;int> 就是表示 int对象集合 的类型。</li>
</ul>
</li>
<li><p><code>vector</code>实例化类型的定义和初始化<br/>
 <img src="vectorInitialize.jpg" alt="" /></p>

<ul>
<li>注意：后两种被称作为“列表初始化”，这个列表只能被放在花括号里，而不能放在圆括号里！</li>
</ul>


<pre><code> vector&lt;int&gt; v1{1, 2, 3};        // ✅
 vector&lt;int&gt; v2 = {1, 2, 3};     // ✅
 vector&lt;int&gt; v3(1, 2, 3);        // ❌
</code></pre>

<ul>
<li>如何判断 “是 列表初始值 还是 元素数量/元素初值”？<strong>“花括号”vs."圆括号"</strong><br/>
初始化的真实含义：依赖于传递初始值时所用的是 “花括号” 还是 “圆括号”！</li>
</ul>


<pre><code> vector&lt;int&gt; v1(10);         // 圆括号，代表 v1 初始化有10个元素，初值默认均为0
 vector&lt;int&gt; v2{10};         // 花括号，代表 v2 初始化只有1个元素，该元素值为10

 vector&lt;int&gt; v3(10, 1);      // 圆括号，代表 v3 初始化有10个元素，初始值被设为 1
 vector&lt;int&gt; v4{10, 1};      // 花括号，代表 v4 初始化只有2个元素，它们分别为10和1

 // 但也请注意
 vector&lt;string&gt; v5{10, "hi"}; // 也是正确的，这里的10不是string类型的，无法用于初值
 vector&lt;string&gt; v6{10};       // 也是正确的，编译器将这里的10用作了代表元素个数的含义
</code></pre></li>
<li><p>向 <code>vector</code> 中动态添加元素 <strong>push_back()方法</strong></p>

<ul>
<li><p>注意：在 C++ 中，使用 vector 不要过多的依赖初始化，而<font color="blue">应该更多地使用 <strong>push_back()方法</strong> 进行动态添加</font>，这是因为：C++标准要求vector要能在运行时高效快速地添加元素，所以一开始创建空元素，然后再在运行时动态添加元素，这种方法往往反而比在一开始就初始化更高效！</p></li>
<li><p>切记：<code>范围for循环 for(i:arr)</code> 循环体内不能改变其所遍历序列arr的大小！所以不要尝试在 <code>范围for循环</code>中向vector动态添加元素！</p></li>
</ul>
</li>
<li><p>vector对象上的 其他操作<br/>
 <img src="vectorOperation.jpg" alt="" /></p>

<ul>
<li>注意：<code>size()</code> 函数的返回值类似 string.size()，类型为 <code>vector&lt;T&gt;::size_type</code>，它是无符号(unsigned)类型的！切记：<font color="red">不可与 有符号类型的 signed 数字混用</font>！❌</li>
<li>注意：vector对象的 <code>[] 下标运算符</code> 只可用于访问已存在的元素，而不能用于添加元素！
<font color="red">不要试图用 下标运算符 添加元素</font>！❌</li>
</ul>
</li>
</ol>


<h2></h2>

<h4>3.4 迭代器介绍</h4>

<ol>
<li><p><code>string</code> 和 <code>vector</code> 除了支持使用下标运算符访问元素之外，还可使用另一种更通用的机制 <code>迭代器(iterator)</code> 来实现同样的目的！</p>

<ul>
<li>标准库中的容器，都可以使用迭代器访问，但只有少数几种容器同时支持下标运算符（比如：vector）！</li>
</ul>
</li>
<li><p>迭代器的使用 (类型不用写那么长，其实我们并不关心，所以可以直接用<code>auto</code>代替类型即可，方便且快捷)</p>

<ul>
<li>容器本身自带 <strong>begin()</strong> 和 <strong>end()</strong> 成员函数，用于获取迭代器！</li>
<li>如果容器为空，则 <strong>begin()</strong> 和 <strong>end()</strong> 返回的就是同一个尾后迭代器(end iterator)。</li>
</ul>
</li>
<li><p>迭代器(iterator) 上的 操作<br/>
 <img src="iteratorOperation.jpg" alt="" /></p></li>
<li><p>迭代器类型</p>

<ul>
<li><p>就像 string 和 vector 的 size_type 成员类型具体是什么，我们并不需要太过关心！<br/>
迭代器的精确类型我们往往也不需要太过于关心，<font color="blue">只需要用 <code>auto</code> 关键字代替即可！</font></p></li>
<li><p>实际上标准库为其定义了 iterator 和 const_iterator 来表示迭代器的类型，const_iterator和常量指针则有些类似！</p></li>
</ul>
</li>
<li><p><code>cbegin(), cend()</code> 与 <code>begin(), edn()</code> 之间的区别</p>

<ul>
<li>这两个函数也分别返回指示着 第一个元素 和 最后元素的下一个位置 的迭代器，但不同之处在于：它们返回的是 const_iterator 类型的迭代器。</li>
<li>这里可以这样理解：<code>cbegin() = const_begin()</code> <code>cend() = const_end()</code>。</li>
</ul>


<p> <font color="red">谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器内添加元素，因为这会导致迭代器失效！</font></p></li>
</ol>


<blockquote><p>他山之石：<br/>
问：<code>二分查找</code> 中为什么用的是 <code>mid = beg + (end-beg)/2</code> 而非 <code>mid = (beg + end)/2</code> 呢？<br/>
答：因为<code>(beg+end)</code>超出了容器的实际可用元素的范围，使用 <code>(beg+end)/2</code>会得到 缓冲区溢出错误！而使用前者则不会出现这种问题。<br/>
联想：在基于数组的二分查找算法中我们也会遇到 <code>the statement m = (l+r)/2 will fail for large values of l and r.</code> 这种尴尬！<br/>
解决方案也是：通过使用 <code>int mid = low + ((high - low) / 2);</code> 这种方式来找中间值。</p></blockquote>

<h2></h2>

<h4>3.5 数组</h4>

<ol>
<li><p>数组是一种类似于 <code>vector</code> 的数据结构，但它的大小确定不变，不能随意向数组中增加元素。</p>

<ul>
<li>这样做的好处：固定数组大小，程序运行性能变得较好；</li>
<li>这样做的坏处：固定数组大小，程序也相应损失了一些灵活性。</li>
</ul>


<p> <font color="red">如果你不清楚数组元素的确切个数，还是请你使用 vector。</font></p></li>
<li><p>数组的定义和初始化</p>

<ul>
<li>要想理解数组声明的含义：最好的办法是从数组的名字开始按照由内而外的顺序阅读！</li>
</ul>


<pre><code> 比如：
     int (*Parray)[10] = &amp;arr; 
     // Parray是一个指针，它指向 一个含有10个int型整数的数组。
     // arr[10] = {1, 2, 3, ...}
     // Parray = &amp;arr;   (*Parray)[0] = arr[0] = 1

     int (&amp;arrRef)[10] = arr;
     // arrRef是一个引用，它是 一个含有10个int型整数的数组 的别名！
     // arr[10] = {1, 2, 3, ...}
     // arrRef = arr;  (arrRef)[0] = arr[0] = 1
</code></pre></li>
<li><p>思考：如何让数组下标可变成负值？</p>

<ul>
<li>这就要求我们深刻理解 <code>数组下标</code> 的本质含义：</li>
</ul>


<pre><code> 数组名本质上就是一个指针，只要这个指针所指向的是数组中的元素，那么都可以执行`下标运算`！
 int arr[5] = {1,2,3,4,5};
 int *p = arr+2;
 int a = arr[1];     // ✅ a = 2
 int b = p[1];       // ✅ b = 4
 int c = p[-2];      // ✅ c = 1，注意此时下标运算就是负值了！
</code></pre>

<ul>
<li>注意：<font color="red">内置的下标运算符所用的 索引值 不是无符号类型</font>，这一点与 vector和string 都不同！</li>
</ul>
</li>
<li><p>C 风格字符串 (c string)</p></li>
</ol>


<blockquote><p>注意：<font color="blue">尽量使用标准库类型而非数组</font>！<br/>
- 现代的 C++ 程序 应当尽量使用 <code>vector</code>容器和迭代器，避免使用内置数组和指针！应当尽量使用<code>string</code>，而避免使用C风格的基于数组的字符串！<br/>
- 这是因为使用指针和数组，极容易引发 <code>内存溢出</code> 或 <code>out of bounds</code> 错误！</p></blockquote>

<h2></h2>

<h4>3.6 多维数组</h4>

<ol>
<li><p>多维数组的初始化</p>

<pre><code> int arr[3][4] = {       // 三个元素，每个元素均是大小为4的数组
     {0, 1, 2, 3},
     {4, 5, 6, 7},
     {8, 9, 10, 11}
 };                      // 用 花括号 将它们都括起来，就可以初始化了
</code></pre></li>
<li><p>要使用<code>范围for循环</code>语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型！(如果你不想改变它的值，那就采用 const int&amp; 常量引用)！</p></li>
</ol>


<h2></h2>

<p>END <a href="../part1-foundation.html">Back</a></p>

<h2></h2>
</body>
</html>